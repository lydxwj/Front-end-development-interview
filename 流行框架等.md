# vue

## 1.v-if和v-show区别

- #### 手段：v-if是动态的向DOM树内添加或者删除DOM元素；v-show是通过设置DOM元素的display样式属性控制显隐；

- #### 编译过程：v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换；

- #### 编译条件：v-if是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译（编译被缓存？编译被缓存后，然后再切换的时候进行局部卸载); v-show是在任何条件下（首次条件是否为真）都被编译，然后被缓存，而且DOM元素保留；

- #### 性能消耗：v-if有更高的切换消耗；v-show有更高的初始渲染消耗；

- #### 使用场景：v-if适合运营条件不大可能改变；v-show适合频繁切换。

### 详情请参考:

http://www.cnblogs.com/wmhuang/p/5420344.html

## 2.vue组件之间传参

- #### 父与子组件传参1（父传子）

  - 父组件

    ```vue
    <template>
    	<div class='tmpl'>
    		<SubVue :tosubdata="tosubdata"></SubVue>
    		<sub-vue :tosubdata="tosubdata"></sub-vue>
    	</div>
    </template>
    <script>
    import SubVue from './sub.vue'
    	export default{
    		data(){
    			return {
    				tosubdata:'来自于parnet.vue组件的数据'
    			}
    		},
    		components:{  //负责注册所有要使用的子组件
    			SubVue  //注册sub.vue组件对象
    		}
    	}
    </script>
    <style>
    </style>
    ```

  - 子组件

    ```vue
    <template>
    	<div class='tmpl'>
    		<div class="subvue">{{msg}}
    			<div>{{tosubdata}} </div>
    		</div>
    	</div>
    </template>
    <script>
    	export default{
    		data(){
    			return {
    				msg:'这是sub.vue中的内容'
    			}
    		},
    		props:['tosubdata']
    	}
    </script>
    <style>
    </style>
    ```

- #### 父与子组件传参2（子传给父）

  - 父组件

    ```vue
    <template>
        <div class="tmpl">  
            购买数量：<sub-number class="subnumber" v-on:count="getcount"></sub-number>
        </div>
    </template>
    <style scoped>
    </style>
    <script>
    import SubNumber from '../subcomp/subnumber.vue';
        export default{
            data(){
                return{
                    goodscount:1, //商品的数量
                }
            },
            created(){         
            },
            methods:{
                //定义一个方法用来接收子组件传入过来的值
                getcount(obj){
                    this.goodscount = obj.count;
                }
            },
            components:{
                SubNumber
            }
        }
    </script>
    ```

  - 子组件

    ```vue
    <template>
        <div class="subtmpl">
            <div class="left" @click="substrict">-</div>
            <div class="middle">{{resObj.count}}</div>
            <div class="right" @click="add">+</div>
        </div>
    </template>
    <style scoped>
    </style>
    <script>
        export default{
            data(){
                return{
                    resObj:{type:ADD,goodsid:0,count:0}
                }
            }
            methods:{
               add(){
                    this.resObj.count++;
                    this.resObj.type=ADD;
                    this.notiflycount();
               },
                substrict(){
                    if(this.resObj.count <= 1){
                        this.resObj.count = 1;
                        return;
                    }
                    this.resObj.count--;
                    this.resObj.type=SUBSTRICT;
                    this.notiflycount();
                },
                notiflycount(){
                    let key = 'count';
                    this.$emit(key,this.resObj); //当执行了这个代码以后，就会自动触发父组件中的getcount()
                }
            }
        }
    </script>
    ```

- #### 组件传参3（没有父子关系）

  - 公共js

    ```jsx
    import Vue from 'vue';
    export  var vueobj = new Vue();
    ```

  - 传参组件

    ```vue
    <template>
        <div class="tmpl">
            <div class="sell">
                <mt-button type="danger" size="small" @click="toshopdata">加入购物车</mt-button>
            </div>
        </div>
    </template>
    <style scoped>
    </style>
    <script>
    //1. 注册commonvue.js
    import {vueobj} from '../../kits/commonvue.js';
        export default{
            data(){
                return{
                    goodscount:1, 
                }
            },
            methods:{            
                // 3.方法实现购物数据的通知
                toshopdata(){
                    vueobj.$emit('shopdata',this.goodscount);
                }
            }
        }
    </script>
    ```

  - 接收组件

    ```vue
    <template>
    	<nav  class="mui-bar mui-bar-tab">	
    		<span class="mui-icon mui-icon-home">
    			<span id="badge" class="mui-badge">0</span>
    		</span>
    			<span class="mui-tab-label">购物车</span>
    		</router-link>
    	</nav>
    </template>
    <script>
    	//1. 注册commonvue.js(用来接收goodsinfo.vue中通过vueobj.$emit()发送过来的数据 )
    	import {vueobj} from './kits/commonvue.js';
    	//2.注册接收事件
    	vueobj.$on('shopdata',function(data){
    		//由于vueobj和export default是不同的vue对象，所以在此处必须通过原生js来操作dom实现购物车数量的增加
    		let badge = document.getElementById('badge');
    		let count = badge.innerText - 0; 
    		count+=data;  
    		badge.innerText = count;
    	});
    </script>
    <style scoped>
    </style>
    ```

## 3.vue路由

```
npm install vue-router --save
```

```jsx
import vueRouter form 'vue-router'
import Vue from 'vue'
Vue.use(vueRouter)
let router = new vueRouter({
	routes:[
		{name:'Login',path:'/Account/Login/:id/:name',component:Login},
		{name:'Register',path:'/Account/Register',component:Register},
		{name:'res',path:'/vueres',component:vueres},
	]
});
new Vue({
	el:'#app',
	router,
	render:c=>c(App)
});
```

## 4.vue生命周期

- #### `beforeCreate`

在实例初始化之后，数据观测(data observer) 和 event/watcher 事件配置之前被调用。

- #### `created`

实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。

- #### `beforeMount`

在挂载开始之前被调用：相关的 render 函数首次被调用。

- #### `mounted`

el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。

- #### `beforeUpdate`

数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。 你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。

- #### `updated`

由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。

当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。

该钩子在服务器端渲染期间不被调用。

- #### `beforeDestroy`

实例销毁之前调用。在这一步，实例仍然完全可用。

- #### `destroyed`

Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 该钩子在服务器端渲染期间不被调用。

### 详情请参考:

https://segmentfault.com/a/1190000008010666

http://www.cnblogs.com/fly_dragon/p/6220273.html

## 5.vue监听对象的具体属性

```jsx
data() {
　　return {
　　　　bet: {
　　　　　　pokerState: 53,
　　　　　　pokerHistory: 'local'
　　　　}   
    }
},
computed: {
　　pokerHistory() {
　　　　return this.bet.pokerHistory
　　}
},
watch: {
　　pokerHistory(newValue, oldValue) {
　　　　console.log(newValue)
　　}
}
```

### 详情请参考:

http://www.jianshu.com/p/d01e145388fc

## 6.简介vuex

- #### Vuex 是一个专为 Vue.js 应用程序开发的**状态管理模式**。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。

- #### 每一个 Vuex 应用的核心就是 store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的**状态 (state)**。Vuex 和单纯的全局对象有以下两点不同：

  1. Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。
  2. 你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地**提交 (commit) mutation**。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用

- #### [安装](https://vuex.vuejs.org/zh-cn/installation.html) Vuex 之后，让我们来创建一个 store。创建过程直截了当——仅需要提供一个初始 state 对象和一些 mutations：

  ```vue
  // 如果在模块化构建系统中，请确保在开头调用了 Vue.use(Vuex)
  
  const store = new Vuex.Store({
    state: {
      count: 0
    },
    mutations: {
      increment (state) {
        state.count++
      }
    }
  })
  ```

- #### 现在，你可以通过 `store.state` 来获取状态对象，以及通过 `store.commit` 方法触发状态变更：

  ```vue
  store.commit('increment')
  console.log(store.state.count) // -> 1
  ```

- #### 再次强调，我们通过提交 mutation 的方式，而非直接改变 `store.state.count`，是因为我们想要更明确地追踪到状态的变化。

### 详情参考：

https://vuex.vuejs.org/zh-cn/

## 7.二级联动vue

http://blog.csdn.net/lllo3o/article/details/72955701

## 8.vue修饰符

### v-on

- `.stop` - 调用 `event.stopPropagation()`。
- `.prevent` - 调用 `event.preventDefault()`。
- `.capture` - 添加事件侦听器时使用 capture 模式。
- `.self` - 只当事件是从侦听器绑定的元素本身触发时才触发回调。
- `.{keyCode | keyAlias}` - 只当事件是从特定键触发时才触发回调。
- `.native` - 监听组件根元素的原生事件。
- `.once` - 只触发一次回调。
- `.left` - (2.2.0) 只当点击鼠标左键时触发。
- `.right` - (2.2.0) 只当点击鼠标右键时触发。
- `.middle` - (2.2.0) 只当点击鼠标中键时触发。
- `.passive` - (2.3.0) 以 `{ passive: true }` 模式添加侦听器

### v-bind

- `.prop` - 被用于绑定 DOM 属性 (property)。([差别在哪里？](https://stackoverflow.com/questions/6003819/properties-and-attributes-in-html#answer-6004028))
- `.camel` - (2.1.0+) 将 kebab-case 特性名转换为 camelCase. (从 2.1.0 开始支持)
- `.sync` (2.3.0+) 语法糖，会扩展成一个更新父组件绑定值的 `v-on` 侦听器。

### v-model

- [`.lazy`](https://cn.vuejs.org/v2/guide/forms.html#lazy) - 取代 `input` 监听 `change` 事件
- [`.number`](https://cn.vuejs.org/v2/guide/forms.html#number) - 输入字符串转为有效的数字
- [`.trim`](https://cn.vuejs.org/v2/guide/forms.html#trim) - 输入首尾空格过滤

## 9.vue路由原理

- vue-rouetr在实现单页面前端路由时，提供了两种方式：**Hash模式**和**History模式**；根据mode参数来决定采用哪一种方式。
- Hash模式： 
        hash（#）是URL 的锚点，代表的是网页中的一个位置，单单改变#后的部分，浏览器只会滚动到相应位置，不会重新加载网页，也就是说 #是用来指导浏览器动作的，对服务器端完全无用，HTTP请求中也不会不包括#；同时每一次改变#后的部分，都会在浏览器的访问历史中增加一个记录，使用”后退”按钮，就可以回到上一个位置；

- History模式： 

  HTML5 History API提供了一种功能，能让开发人员在不刷新整个页面的情况下修改站点的URL，就是利用 history.pushState API 来完成 URL 跳转而无须重新加载页面

- 通常情况下，我们会选择使用History模式，原因就是Hash模式下URL带着‘#’会显得不美观；但实际上，这样选择一不小心也会出问题；比如：

  但当用户直接在用户栏输入地址并带有参数时： 
  Hash模式：xxx.com/#/id=5 请求地址为 xxx.com,没有问题; 
  History模式: xxx.com/id=5 请求地址为 xxx.com/id=5，如果后端没有对应的路由处理，就会返回404错误；

- 为解决这一问题，vue-router提供的方法是：

  - 在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。 

  - 给个警告，因为这么做以后，你的服务器就不再返回 404 错误页面，因为对于所有路径都会返回 index.html 文件。为了避免这种情况，你应该在 Vue 应用里面覆盖所有的路由情况，然后在给出一个 404 页面。或者，如果你使用 Node.js 服务器，你可以用服务端路由匹配到来的 URL，并在没有匹配到路由的时候返回 404，以实现回退。

### 详情参考：

https://blog.csdn.net/github_39532240/article/details/79551130 

## 10.vue双向绑定原理

- 采用数据劫持结合发布者-订阅者模式的方式，通过`Object.defineProperty()`来劫持各个属性的`setter`，`getter`，在数据变动时发布消息给订阅者，触发相应的监听回调

- vue如何实现

  ![img](https://images2017.cnblogs.com/blog/1162184/201709/1162184-20170918135341618-553576179.png)

  - observer用来实现对每个vue中的data中定义的属性循环用Object.defineProperty()实现数据劫持，以便利用其中的setter和getter，然后通知订阅者，订阅者会触发它的update方法，对视图进行更新。

  - 我们介绍为什么要订阅者，在vue中v-model，v-name，{{}}等都可以对数据进行显示，也就是说假如一个属性都通过这三个指令了，那么每当这个属性改变的时候，相应的这个三个指令的html视图也必须改变，于是vue中就是每当有这样的可能用到双向绑定的指令，就在一个Dep中增加一个订阅者，其订阅者只是更新自己的指令对应的数据，也就是v-model='name'和{{name}}有两个对应的订阅者，各自管理自己的地方。每当属性的set方法触发，就循环更新Dep中的订阅者。

### 详情参考：

https://www.cnblogs.com/zhenfei-jiang/p/7542900.html

https://www.cnblogs.com/libin-1/p/6893712.html

## 11.vue页面缓存

- keep-alive是vue内置的一个组件，可以使被它包含的组件处于保留状态，或避免被重新渲染。

  ```
  <keep-alive>
  	<router-view v-if="$route.meta.keepAlive"></router-view>
  </keep-alive>
  ```

- `include` - 字符串或正则表达式。只有名称匹配的组件会被缓存。

  `exclude` - 字符串或正则表达式。任何名称匹配的组件都不会被缓存。

  `max` - 数字。最多可以缓存多少组件实例。

- 路由

  ```
  {
  	path: '/',
  	meta: {keepAlive: true},
  	component: require('@/components/Home')
  },
  ```

### 详情参考：

https://blog.csdn.net/qq_38614249/article/details/79468609

# git

```jsx
# 在当前目录新建一个Git代码库
$ git init
# 新建一个目录，将其初始化为Git代码库
$ git init [project-name]
# 下载一个项目和它的整个代码历史
$ git clone [url]
# 显示当前的Git配置
$ git config --list
# 编辑Git配置文件
$ git config -e [--global]
# 设置提交代码时的用户信息
$ git config [--global] user.name "[name]"
$ git config [--global] user.email "[email address]"
# 添加指定文件到暂存区
$ git add [file1] [file2] ...
# 添加指定目录到暂存区，包括子目录
$ git add [dir]
# 添加当前目录的所有文件到暂存区
$ git add .
# 提交暂存区到仓库区
$ git commit -m [message]
# 提交暂存区的指定文件到仓库区
$ git commit [file1] [file2] ... -m [message]
# 提交工作区自上次commit之后的变化，直接到仓库区
$ git commit -a
# 提交时显示所有diff信息
$ git commit -v
# 使用一次新的commit，替代上一次提交
# 如果代码没有任何新变化，则用来改写上一次commit的提交信息
$ git commit --amend -m [message]
# 列出所有本地分支
$ git branch
# 列出所有远程分支
$ git branch -r
# 列出所有本地分支和远程分支
$ git branch -a
# 新建一个分支，但依然停留在当前分支
$ git branch [branch-name]
# 显示有变更的文件
$ git status
# 显示当前分支的版本历史
$ git log
# 显示commit历史，以及每次commit发生变更的文件
$ git log --stat
# 显示当前分支的最近几次提交
$ git reflog
# 上传本地指定分支到远程仓库
$ git push [remote] [branch]
```

### 详情请参考:

http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html

https://mp.weixin.qq.com/s/hYjGyIdLK3UCEVF0lRYRCg

https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000

# node

## 1. node服务崩溃处理方法

- #### 使用uncaughtException

  uncaughtException来全局捕获未捕获的Error，同时你还可以将此函数的调用栈打印出来，捕获之后可以有效防止node进程退出，如： 

  ```
  process.on('uncaughtException', function (err) {
    //打印出错误
    console.log(err);
    //打印出错误的调用栈方便调试
    console.log(err.stack)；
  });
  ```

  这相当于在node进程内部进行守护， 但这种方法很多人都是不提倡的，说明你还不能完全掌控Node.JS的异常。 

- #### 使用 try/catch

  我们还可以在回调前加try/catch，同样确保线程的安全。 

  ```
  var http = require('http');

  http.createServer(function(req, res) {
    try {
      handler(req, res);
    } catch(e) {
      console.log('\r\n', e, '\r\n', e.stack);
      try {
        res.end(e.stack);
      } catch(e) { }
    }
  }).listen(8080, '127.0.0.1');

  console.log('Server running at http://127.0.0.1:8080/');

  var handler = function (req, res) {
    //Error Popuped
    var name = req.params.name;

    res.writeHead(200, {'Content-Type': 'text/plain'});
    res.end('Hello ' + name);
  };
  ```

  这种方案的好处是，可以将错误和调用栈直接输出到当前发生的网页上。 

  ### 详情请参考:

  http://www.oschina.net/question/433035_171960

  ## 2.node操作数据库

  - #### 首先通过npm命令安装[MySQL](http://lib.csdn.net/base/mysql)模块 

  ```jsx
  var mysql  = require('mysql');  //调用MySQL模块
  //创建一个connection
  var connection = mysql.createConnection({    
      host     : '127.0.0.1',       //主机
      user     : 'root',            //MySQL认证用户名
      password:'12345',
      port:   '3306',
      database: 'node'
  });
  //创建一个connection
  connection.connect(function(err){
      if(err){       
          console.log('[query] - :'+err);
          return;
      }
      console.log('[connection connect]  succeed!');
  }); 
  //执行SQL语句
  connection.query('SELECT 1 + 1 AS solution', function(err, rows, fields) {
      if (err) {
          console.log('[query] - :'+err);
          return;
      }
      console.log('The solution is: ', rows[0].solution); 
  }); 
  //关闭connection
  connection.end(function(err){
      if(err){       
          return;
      }
      console.log('[connection end] succeed!');
  });
  ```

### 详情请参考:

http://blog.csdn.net/zxc123e/article/details/53232409

## 3.node介绍

- #### Node.js优点：

　　1、采用事件驱动、异步编程，为网络服务而设计。其实Javascript的匿名函数和闭包特性非常适合事件驱动、异步编程。而且JavaScript也简单易学，很多前端设计人员可以很快上手做后端设计。
　　2、Node.js非阻塞模式的IO处理给Node.js带来在相对低系统资源耗用下的高性能与出众的负载能力，非常适合用作依赖其它IO资源的中间层服务。

　　3、Node.js轻量高效，可以认为是数据密集型分布式部署环境下的实时应用系统的完美解决方案。Node非常适合如下情况：在响应客户端之前，您预计可能有很高的流量，但所需的服务器端逻辑和处理不一定很多。

- #### Node.js缺点：

　　1、可靠性低
　　2、单进程，单线程，只支持单核CPU，不能充分的利用多核CPU服务器。一旦这个进程崩掉，那么整个web服务就崩掉了。

```jsx
var server = http.createServer()
server.on('request', function (req, res) {
  // 3.1.通过 req.url 拿到当前请求路径
  var url = req.url
  // 3.2根据不同的请求路径，处理不同的响应
  if (url === '/') {
    // res.writeHead(响应状态码, 响应头对象)
    res.writeHead(200, {
      'Content-Type': 'text/html'
    })
    fs.readFile('./data/index.html', 'utf8', function (err, data) {
      if (err) {
        throw err
      }
      res.end(data)		// 在发送数据完毕之后，主动结束响应
    })
  } else if (url === '/login') {
    res.writeHead(200, {
      'Content-Type': 'text/html'
    })
    fs.readFile('./data/login.html', 'utf8', function (err, data) {
      if (err) {
        throw err
      }
      res.end(data)
    })
  } else {
    fs.readFile('./data/404.html', 'utf8', function (err, data) {
      if (err) {
        throw err
      }
      res.end(data)
    })
  }
})
server.listen(3000, function () {
  console.log('running...')
})
```

### 详情请参考:

http://www.cnblogs.com/GumpYan/p/5940368.html

# react

## 1.react生命周期

- #### 初始化阶段：

  getDefaultProps:获取实例的默认属性(即使没有生成实例，组件的第一个实例被初始化CreateClass的时候调用，只调用一次,)

  getInitialState:获取每个实例的初始化状态（每个实例自己维护）

  componentWillMount：组件即将被装载、渲染到页面上（render之前最好一次修改状态的机会）

  render:组件在这里生成虚拟的DOM节点（只能访问this.props和this.state；只有一个顶层组件，也就是说render返回值值职能是一个组件；不允许修改状态和DOM输出）

  componentDidMount:组件真正在被装载之后，可以修改DOM

- #### 运行中状态： 

  componentWillReceiveProps:组件将要接收到属性的时候调用（赶在父组件修改真正发生之前,可以修改属性和状态）

  shouldComponentUpdate:组件接受到新属性或者新状态的时候（可以返回false，接收数据后不更新，阻止render调用，后面的函数不会被继续执行了）

  componentWillUpdate:不能修改属性和状态

  render:只能访问this.props和this.state；只有一个顶层组件，也就是说render返回值只能是一个组件；不允许修改状态和DOM输出

  componentDidUpdate:可以修改DOM

- #### 销毁阶段：

  componentWillUnmount:开发者需要来销毁（组件真正删除之前调用，比如计时器和事件监听器）

- ### 17版本中去掉的生命周期钩子函数

  - componentWillMount
  - componentWillRecieveProps
  - componentWIllUpdate

- ### 新增两个

  - static getDerivedStateFromProps
    会在初始化和update时触发，用于替换componentWillReceiveProps，可以用来控制 props 更新 state 的过程；它返回一个对象表示新的 state；如果不需要更新，返回 null 即可
  - getSnapshotBeforeUpdate
    用于替换 componentWillUpdate，该函数会在update后 DOM 更新前被调用，用于读取最新的 DOM 数据，返回值将作为 componentDidUpdate 的第三个参数

#### 详情参考：

https://www.jianshu.com/p/b634018d118e

## 2.React 16.3新特性Context API

- `React.createContext()`，这样就创建了两个组件

  ```
  import {createContext} from 'react';
  const ThemeContext = createContext({
    background: 'yellow',
    color: 'white'
  });
  ```

- 调用`createContext`方法会返回两个对象，一个是`Provider`，一个是`Consumer`。

- `Provider`是一个特殊的组件。它可以用来给子树里的组件提供数据

  ```
  class Application extends React.Component {
    render() {
      <ThemeContext.Provider value={{background: 'black', color: 'white'}}>
        <Header />
        <Main />
        <Footer />
      </ThemeContext.Provider>
    }
  }
  ```

  value可以是动态的（比如，基于this.state）。对`Provider`数据的修改会引起所有的消费者（consumer）重绘。

- 使用Consumer。

      const Header = () => {
        <ThemeContext.Consumer>
          {(context) => {
            return (
              <p style={{background: context.background, color: context.color}}>
                Welcome!
              </p>
            );
          }}
        </ThemeContext.Consumer>
      }

  如果在render Consumer的时候没有嵌套在一个Provider里面。那么就会使用createContext方法调用的时候设置的默认值。

- *Consumer*必须可以访问到同一个*Context*组件。如果你要创建一个新的context，用的是同样的入参，那么这个新建的context的数据是不可访问的。因此，可以把*Context*当做一个组件，它可以创建一次，然后可以export，可以import。

### 详情请参考:

http://www.php.cn/js-tutorial-386621.html

## 3.react优缺点

- **React速度很快**

与其它框架相比，React采取了一种特立独行的操作DOM的方式。它并不直接对DOM进行操作。它引入了一个叫做虚拟DOM的概念，安插在JavaScript逻辑和实际的DOM之间。这一概念提高了Web性能。在UI渲染过程中，React通过在虚拟DOM中的微操作来实对现实际DOM的局部更新。

- **跨浏览器兼容**

虚拟DOM帮助我们解决了跨浏览器问题，它为我们提供了标准化的API，甚至在IE8中都是没问题的。

- **模块化**

为你程序编写独立的模块化UI组件，这样当某个或某些组件出现问题是，可以方便地进行隔离。
每个组件都可以进行独立的开发和测试，并且它们可以引入其它组件。这等同于提高了代码的可维护性。

- **单向数据流让事情一目了然**

Flux是一个用于在JavaScript应用中创建单向数据层的架构，它随着React视图库的开发而被Facebook概念化。它只是一个概念，而非特定工具的实现。它可以被其它框架吸纳。例如，Alex Rattray有一个很好的Flux实例，在React中使用了Backbone的集合和模型。

- **纯粹的JavaScript**

现代Web应用程序与传统的Web应用有着不同的工作方式。例如，视图层的更新需要通过用户交互而不需要请求服务器。因此视图和控制器非常依赖彼此。许多框架使用Handlebars或Mustache等模板引擎来处理视图层。但React相信视图和控制器应该相互依存在一起而不是使用第三方模板引擎，而且，最重要的是，它是纯粹的JavaScript程序。

- **同构的JavaScript**

单页面JS应用程序的最大缺陷在于对搜索引擎的索引有很大限制。React对此有了解决方案。React可以在服务器上预渲染应用再发送到客户端。它可以从预渲染的静态内容中恢复一样的记录到动态应用程序中。
因为搜索引擎的爬虫程序依赖的是服务端响应而不是JavaScript的执行，预渲染你的应用有助于搜索引擎优化。

- **React与其它框架/库兼容性好**

比如使用RequireJS来加载和打包，而Browserify和Webpack适用于构建大型应用。它们使得那些艰难的任务不再让人望而生畏。

- **缺点**

React本身只是一个V而已，所以如果是大型项目想要一套完整的框架的话，也许还需要引入Flux和routing相关的东西。

大多数坑没踩出来

## 4.什么情况下使用redux

- 某个组件的状态，需要共享
- 某个状态需要在任何地方都可以拿到
- 一个组件需要改变全局状态
- 一个组件需要改变另一个组件的状态

# angular

## 1.angular路由

```jsx
var App = angular.module('App', ['ngRoute']);    
//3 配置路由模块，使其正常工作  
App.config(['$routeProvider', function ($routeProvider) {  	
  $routeProvider.when('/index', {  
    	// template: '<h1>index Pages!</h1>',  
   	 	templateUrl: './abc.html'  
  })  
  .when('/introduce', {  
 	 	template: '<h1>introduce Pages!</h1>'  
  })  
  .when('/contact', {  
    	// template: '<h1>contact US Pages!</h1>',  
    	templateUrl: './contact.html',  
        controller: 'ContactController' // 定义控制器  
  })  
  .when('/list', {  
      templateUrl: './list.html', // 视图模板  
      controller: 'ListController' // 定义控制器  
  })  
  .otherwise({  
      redirectTo: '/index'  
  });  
}]);  
```

### 详情请参考:

http://blog.csdn.net/u011301203/article/details/53236671

## 2.”脏“查询什么时候触发

- #### controller初始化的时候

- #### 所有以ng-开头的事件爱你执行后

- #### 手动的触发脏检查：$apply仅仅只是进入angular context，然后通过$digest触发脏检查

### 详情请参考:

http://www.cnblogs.com/liuyanan/p/4935652.html

http://www.cnblogs.com/likeFlyingFish/p/6183630.html

http://www.webnpm.com/60.html

# 小程序

## 1.小程序怎么页面传参

# 综合

## 1.vue和angular或react区别

- #### vue和angular

1. vue仅仅是mvvm中的view层，只是一个如jquery般的工具库，而不是框架，而angular而是mvvm框架。
2. vue的双向邦定是基于ES5 中的 getter/setter来实现的，而angular而是由自己实现一套模版编译规则，需要进行所谓的“脏”检查，vue则不需要。因此，vue在性能上更高效，但是代价是对于ie9以下的浏览器无法支持。
3. vue需要提供一个el对象进行实例化，后续的所有作用范围也是在el对象之下，而angular而是整个html页面。一个页面，可以有多个vue实例，而angular好像不是这么玩的。
4. vue真的很容易上手，学习成本相对低，不过可以参考的资料不是很丰富，官方文档比较简单，缺少全面的使用案例。高级的用法，需要自己去研究源码，至少目前是这样。

- #### vue/angular/react

  React 和 Vue 有许多相似之处，它们都有：
  1.使用 Virtual DOM
  2.提供了响应式（Reactive）和组件化（Composable）的视图组件。
  3.将注意力集中保持在核心库，伴随于此，有配套的路由和负责处理全局状态管理的库。 

  React 和 Vue 的区别：
  1.复杂性
  在 API 与设计两方面上 Vue.js 都比 Angular 1 简单得多，因此你可以快速地掌握它的全部特性并投入开发。
  2.灵活性和模块化
  Vue.js 是一个更加灵活开放的解决方案。它允许你以希望的方式组织应用程序，而不是在任何时候都必须遵循 Angular 1 制定的规则，这让 Vue 能适用于各种项目。我们知道把决定权交给你是非常必要的。 
  这也就是为什么我们提供 Webpack template，让你可以用几分钟，去选择是否启用高级特性，比如热模块加载、linting、CSS 提取等等。
  3.数据绑定
  Angular 1 使用双向绑定，Vue 在不同组件间强制使用单向数据流。这使应用中的数据流更加清晰易懂。
  4.指令与组件
  在 Vue 中指令和组件分得更清晰。指令只封装 DOM 操作，而组件代表一个自给自足的独立单元 —— 有自己的视图和数据逻辑。在 Angular 中两者有不少相混的地方。
  5.性能
  Vue 有更好的性能，并且非常非常容易优化，因为它不使用脏检查。

### 详情请参考:

http://blog.csdn.net/llm913114267/article/details/69068414

http://www.cnblogs.com/Zcqian/p/6843787.html

http://www.jb51.net/article/108388.htm

http://blog.csdn.net/qq_35844177/article/details/54915615

## 2.common/AMD/CMD规范

- #### 在CommonJs规范中：

  ​    一个文件就是一个模块，拥有单独的作用域；

  ​    普通方式定义的变量、函数、对象都属于该模块内；

  ​    通过require来加载模块；

  ​    通过exports和modul.exports来暴露模块中的内容；

- #### AMD 异步模块定义RequireJS

  加载依赖的函数的时候是异步加载的，这样浏览器不会失去响应，它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。在定义模块的时候就要声明其依赖的模块

- #### CMD通用模块定义SeaJS

  Sea.js 推崇一个模块一个文件，遵循统一的写法 ，只有在用到某个模块的时候再去require

### 详情请参考:

http://www.cnblogs.com/littlebirdlbw/p/5670633.html

http://blog.csdn.net/jackwen110200/article/details/52105493

http://blog.csdn.net/xcymorningsun/article/details/52709608

http://www.cnblogs.com/chenguangliang/p/5856701.html

## 3.使用react/vue或其他框架，编写一个简单的Todolist组件，可以不考虑样式，点击添加按钮后，可以把input内容加入到下方的列表中，列表中事项点击后，可以删除。

```
import React, { Component } from 'react';
let id = 0;
export default class Todo extends Component {
  constructor(props) {
    super(props)
    this.state = {
      list: [],
      value: '',
    },
    this.$input = React.createRef();
  }
  delete(id) {
    const list = this.state.list.filter(item => {
      return item.id !== id;
    });
    this.setState({
      list,
    });
  }
  add() {
    const value = this.state.value;
    if (value.trim()) {
      const list = this.state.list;
      list.push({
        value,
        id: id++,
      });
      this.setState({
        list,
        value: '',
      });
    }
  }
  change() {
    const value = this.$input.current.value;
    this.setState({
      value,
    });
  }
  __renderList(list) {
    return (
      <ul>
        {list.map(item => {
          return <li key={item.id} onClick={this.delete.bind(this, item.id)}>{item.value}</li>
        })}
      </ul>
    );
  }
  render() {
    const value = this.state.value;
    const list = this.state.list;
    return (
      <div>
        <input value={value} onInput={this.change.bind(this)} ref={this.$input} />
        <button onClick={this.add.bind(this)}>添加</button>
        {this.__renderList(list)}
      </div>
    );
  }
}
```

## 简答题

- ```
  setTimeout(() => {
    console.log(1);
  }, 0);
  new Promise((resolve, reject) => {
    console.log(2);
    setTimeout(() => {
      resolve()
    }, 0);
  }).then(() => {
    console.log(3);
  }).then(() => {
    console.log(4);
  });
  process.nextTick(() => {
    console.log(5);
  });
  console.log(6);
  // 2 6 5 1 3 4
  // process.nextTick(callback)
  //功能：在事件循环的下一次循环中调用 callback 回调函数。效果是将一个函数推迟到代码书写的下一个同步方
  //法执行完毕时或异步方法的事件回调函数开始执行时；与setTimeout(fn, 0) 函数的功能类似，
  //但它的效率高多了。
  ```

- 